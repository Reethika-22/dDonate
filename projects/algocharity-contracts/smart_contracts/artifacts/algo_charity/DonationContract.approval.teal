#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 32
    bytecblock 0x151f7c75 "cause_count" "cause_balance" "donor_donations" "total_donations" "cause_owner"
    // smart_contracts/algo_charity/contract.py:3
    // class DonationContract(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@20
    pushbytes 0x30c6d58a // method "opt_in()void"
    txna ApplicationArgs 0
    match main_opt_in_route@5

main_switch_case_next@6:
    // smart_contracts/algo_charity/contract.py:3
    // class DonationContract(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x676b20bd 0x99d61fc2 0xa381297a 0x9fd6c978 0xe3563de7 0xf3c16be0 0x606dd885 0x4f60bdbd 0xa9d25496 // method "register_cause(string)uint64", method "donate(uint64,uint64)uint64", method "withdraw(uint64,address)void", method "get_total_donations()uint64", method "get_donor_donations()uint64", method "get_cause_balance()uint64", method "get_cause_owner()address", method "get_cause_count()uint64", method "get_sender_address()address"
    txna ApplicationArgs 0
    match register_cause donate withdraw get_total_donations get_donor_donations get_cause_balance get_cause_owner get_cause_count get_sender_address
    err

main_opt_in_route@5:
    // smart_contracts/algo_charity/contract.py:25
    // @arc4.abimethod(allow_actions=["OptIn"])
    txn OnCompletion
    intc_1 // OptIn
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be OptIn && can only call when not creating
    b opt_in

main___algopy_default_create@20:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts.algo_charity.contract.DonationContract.opt_in[routing]() -> void:
opt_in:
    // smart_contracts/algo_charity/contract.py:28
    // self.donor_donations[Txn.sender] = UInt64(0)
    txn Sender
    bytec_3 // "donor_donations"
    intc_0 // 0
    app_local_put
    // smart_contracts/algo_charity/contract.py:25
    // @arc4.abimethod(allow_actions=["OptIn"])
    intc_1 // 1
    return


// smart_contracts.algo_charity.contract.DonationContract.register_cause[routing]() -> void:
register_cause:
    // smart_contracts/algo_charity/contract.py:30
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/algo_charity/contract.py:33
    // count = self.cause_count.value or UInt64(0)
    intc_0 // 0
    bytec_1 // "cause_count"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.cause_count exists
    bz register_cause_ternary_false@3
    dup

register_cause_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:34
    // self.cause_count.value = count + UInt64(1)
    intc_1 // 1
    +
    bytec_1 // "cause_count"
    swap
    app_global_put
    // smart_contracts/algo_charity/contract.py:35
    // self.cause_owner.value = Txn.sender
    bytec 5 // "cause_owner"
    txn Sender
    app_global_put
    // smart_contracts/algo_charity/contract.py:36
    // self.cause_balance.value = UInt64(0)
    bytec_2 // "cause_balance"
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_charity/contract.py:37
    // return arc4.UInt64(self.cause_count.value)
    intc_0 // 0
    bytec_1 // "cause_count"
    app_global_get_ex
    assert // check self.cause_count exists
    itob
    // smart_contracts/algo_charity/contract.py:30
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

register_cause_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:33
    // count = self.cause_count.value or UInt64(0)
    intc_0 // 0
    b register_cause_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.donate[routing]() -> void:
donate:
    pushbytes ""
    dup
    // smart_contracts/algo_charity/contract.py:39
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/algo_charity/contract.py:42
    // assert amount.native > 0, "Donation amount must be greater than zero"
    btoi
    dup
    cover 2
    assert // Donation amount must be greater than zero
    // smart_contracts/algo_charity/contract.py:43
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    btoi
    intc_0 // 0
    bytec_1 // "cause_count"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.cause_count exists
    bz donate_ternary_false@3
    dup

donate_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:43
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    dig 2
    >=
    assert // Invalid cause ID
    // smart_contracts/algo_charity/contract.py:45
    // total = self.total_donations.value or UInt64(0)
    intc_0 // 0
    bytec 4 // "total_donations"
    app_global_get_ex
    swap
    dup
    cover 2
    bury 7
    assert // check self.total_donations exists
    bz donate_ternary_false@6
    dig 4

donate_ternary_merge@7:
    // smart_contracts/algo_charity/contract.py:46
    // self.total_donations.value = total + amount.native
    dig 3
    dup
    cover 2
    +
    bytec 4 // "total_donations"
    swap
    app_global_put
    // smart_contracts/algo_charity/contract.py:48
    // prev_donated = self.donor_donations.get(Txn.sender, UInt64(0))
    txn Sender
    intc_0 // 0
    bytec_3 // "donor_donations"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/algo_charity/contract.py:49
    // self.donor_donations[Txn.sender] = prev_donated + amount.native
    +
    txn Sender
    bytec_3 // "donor_donations"
    uncover 2
    app_local_put
    // smart_contracts/algo_charity/contract.py:51
    // balance = self.cause_balance.value or UInt64(0)
    intc_0 // 0
    bytec_2 // "cause_balance"
    app_global_get_ex
    swap
    dup
    cover 2
    bury 6
    assert // check self.cause_balance exists
    bz donate_ternary_false@9
    dig 3

donate_ternary_merge@10:
    // smart_contracts/algo_charity/contract.py:52
    // self.cause_balance.value = balance + amount.native
    dig 3
    +
    bytec_2 // "cause_balance"
    swap
    app_global_put
    // smart_contracts/algo_charity/contract.py:54
    // return arc4.UInt64(self.total_donations.value)
    intc_0 // 0
    bytec 4 // "total_donations"
    app_global_get_ex
    assert // check self.total_donations exists
    itob
    // smart_contracts/algo_charity/contract.py:39
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

donate_ternary_false@9:
    // smart_contracts/algo_charity/contract.py:51
    // balance = self.cause_balance.value or UInt64(0)
    intc_0 // 0
    b donate_ternary_merge@10

donate_ternary_false@6:
    // smart_contracts/algo_charity/contract.py:45
    // total = self.total_donations.value or UInt64(0)
    intc_0 // 0
    b donate_ternary_merge@7

donate_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:43
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    intc_0 // 0
    b donate_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.withdraw[routing]() -> void:
withdraw:
    pushbytes ""
    // smart_contracts/algo_charity/contract.py:56
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/algo_charity/contract.py:59
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    btoi
    intc_0 // 0
    bytec_1 // "cause_count"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.cause_count exists
    bz withdraw_ternary_false@3
    dup

withdraw_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:59
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    dig 2
    >=
    assert // Invalid cause ID
    // smart_contracts/algo_charity/contract.py:60
    // assert Txn.sender == (self.cause_owner.value), "Only the cause owner can withdraw funds"
    txn Sender
    intc_0 // 0
    bytec 5 // "cause_owner"
    app_global_get_ex
    assert // check self.cause_owner exists
    ==
    assert // Only the cause owner can withdraw funds
    // smart_contracts/algo_charity/contract.py:62
    // amount = self.cause_balance.value or UInt64(0)
    intc_0 // 0
    bytec_2 // "cause_balance"
    app_global_get_ex
    swap
    dup
    cover 2
    bury 5
    assert // check self.cause_balance exists
    bz withdraw_ternary_false@6
    dig 2

withdraw_ternary_merge@7:
    // smart_contracts/algo_charity/contract.py:63
    // assert amount > 0, "No funds available for withdrawal"
    assert // No funds available for withdrawal
    // smart_contracts/algo_charity/contract.py:64
    // self.cause_balance.value = UInt64(0)
    bytec_2 // "cause_balance"
    intc_0 // 0
    app_global_put
    // smart_contracts/algo_charity/contract.py:56
    // @arc4.abimethod
    intc_1 // 1
    return

withdraw_ternary_false@6:
    // smart_contracts/algo_charity/contract.py:62
    // amount = self.cause_balance.value or UInt64(0)
    intc_0 // 0
    b withdraw_ternary_merge@7

withdraw_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:59
    // assert cause_id.native <= (self.cause_count.value or UInt64(0)), "Invalid cause ID"
    intc_0 // 0
    b withdraw_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.get_total_donations[routing]() -> void:
get_total_donations:
    // smart_contracts/algo_charity/contract.py:73
    // return arc4.UInt64(self.total_donations.value or UInt64(0))
    intc_0 // 0
    bytec 4 // "total_donations"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.total_donations exists
    bz get_total_donations_ternary_false@3
    dup

get_total_donations_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:73
    // return arc4.UInt64(self.total_donations.value or UInt64(0))
    itob
    // smart_contracts/algo_charity/contract.py:71
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_total_donations_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:73
    // return arc4.UInt64(self.total_donations.value or UInt64(0))
    intc_0 // 0
    b get_total_donations_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.get_donor_donations[routing]() -> void:
get_donor_donations:
    // smart_contracts/algo_charity/contract.py:77
    // return arc4.UInt64(self.donor_donations.get(Txn.sender, UInt64(0)))
    txn Sender
    intc_0 // 0
    bytec_3 // "donor_donations"
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    itob
    // smart_contracts/algo_charity/contract.py:75
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.algo_charity.contract.DonationContract.get_cause_balance[routing]() -> void:
get_cause_balance:
    // smart_contracts/algo_charity/contract.py:81
    // return arc4.UInt64(self.cause_balance.value or UInt64(0))
    intc_0 // 0
    bytec_2 // "cause_balance"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.cause_balance exists
    bz get_cause_balance_ternary_false@3
    dup

get_cause_balance_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:81
    // return arc4.UInt64(self.cause_balance.value or UInt64(0))
    itob
    // smart_contracts/algo_charity/contract.py:79
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_cause_balance_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:81
    // return arc4.UInt64(self.cause_balance.value or UInt64(0))
    intc_0 // 0
    b get_cause_balance_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.get_cause_owner[routing]() -> void:
get_cause_owner:
    // smart_contracts/algo_charity/contract.py:85
    // return arc4.Address(self.cause_owner.value.bytes)
    intc_0 // 0
    bytec 5 // "cause_owner"
    app_global_get_ex
    assert // check self.cause_owner exists
    dup
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/algo_charity/contract.py:83
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.algo_charity.contract.DonationContract.get_cause_count[routing]() -> void:
get_cause_count:
    // smart_contracts/algo_charity/contract.py:89
    // return arc4.UInt64(self.cause_count.value or UInt64(0))
    intc_0 // 0
    bytec_1 // "cause_count"
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.cause_count exists
    bz get_cause_count_ternary_false@3
    dup

get_cause_count_ternary_merge@4:
    // smart_contracts/algo_charity/contract.py:89
    // return arc4.UInt64(self.cause_count.value or UInt64(0))
    itob
    // smart_contracts/algo_charity/contract.py:87
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_cause_count_ternary_false@3:
    // smart_contracts/algo_charity/contract.py:89
    // return arc4.UInt64(self.cause_count.value or UInt64(0))
    intc_0 // 0
    b get_cause_count_ternary_merge@4


// smart_contracts.algo_charity.contract.DonationContract.get_sender_address[routing]() -> void:
get_sender_address:
    // smart_contracts/algo_charity/contract.py:91
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    // smart_contracts/algo_charity/contract.py:93
    // return arc4.Address(Txn.sender.bytes)
    txn Sender
    // smart_contracts/algo_charity/contract.py:91
    // @arc4.abimethod(readonly=True)
    concat
    log
    intc_1 // 1
    return
